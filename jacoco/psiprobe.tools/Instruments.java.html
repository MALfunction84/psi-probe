<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Instruments.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">psi-probe-core</a> &gt; <a href="index.source.html" class="el_package">psiprobe.tools</a> &gt; <span class="el_source">Instruments.java</span></div><h1>Instruments.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the GPL License. You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 *
 * THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */
package psiprobe.tools;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

/**
 * The Class Instruments.
 */
<span class="fc" id="L25">public class Instruments {</span>

  /** The Constant SIZE_VOID. */
  public static final long SIZE_VOID = 0;

  /** The Constant SIZE_BOOLEAN. */
  public static final long SIZE_BOOLEAN = 1;

  /** The Constant SIZE_BYTE. */
  public static final long SIZE_BYTE = 1;

  /** The Constant SIZE_CHAR. */
  public static final long SIZE_CHAR = 2;

  /** The Constant SIZE_SHORT. */
  public static final long SIZE_SHORT = 2;

  /** The Constant SIZE_INT. */
  public static final long SIZE_INT = 4;

  /** The Constant SIZE_LONG. */
  public static final long SIZE_LONG = 8;

  /** The Constant SIZE_FLOAT. */
  public static final long SIZE_FLOAT = 4;

  /** The Constant SIZE_DOUBLE. */
  public static final long SIZE_DOUBLE = 8;

  /** The Constant SIZE_OBJECT. */
  public static final long SIZE_OBJECT = 8;

  /** The Constant SIZE_REFERENCE. */
  public static final long SIZE_REFERENCE;

  /** The Constant ACCESSOR. */
<span class="fc" id="L61">  private static final Accessor ACCESSOR = new SimpleAccessor();</span>

  /** The Constant IGNORE_NIO. */
  private static final boolean IGNORE_NIO;

  static {
<span class="fc" id="L67">    String ignoreNioProp = System.getProperty(&quot;psiprobe.intruments.ignoreNIO&quot;);</span>
<span class="fc" id="L68">    String os64bitProp = System.getProperty(&quot;sun.arch.data.model&quot;);</span>
<span class="pc bpc" id="L69" title="3 of 4 branches missed.">    IGNORE_NIO = ignoreNioProp == null || &quot;true&quot;.equalsIgnoreCase(ignoreNioProp);</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">    SIZE_REFERENCE = &quot;64&quot;.equals(os64bitProp) ? 8 : 4;</span>
<span class="fc" id="L71">  }</span>

  /** The processed objects. */
<span class="fc" id="L74">  private Set&lt;Object&gt; processedObjects = new HashSet&lt;&gt;(2048);</span>

  /** The this queue. */
<span class="fc" id="L77">  private final List&lt;Object&gt; thisQueue = new LinkedList&lt;&gt;();</span>

  /** The next queue. */
<span class="fc" id="L80">  private final List&lt;Object&gt; nextQueue = new LinkedList&lt;&gt;();</span>

  /** The class loader. */
  private ClassLoader classLoader;

  /**
   * Size of.
   *
   * @param obj the obj
   *
   * @return the long
   */
  public static long sizeOf(Object obj) {
<span class="fc" id="L93">    return new Instruments().internalSizeOf(obj);</span>
  }

  /**
   * Size of.
   *
   * @param obj the obj
   * @param cl the cl
   *
   * @return the long
   */
  public static long sizeOf(Object obj, ClassLoader cl) {
<span class="nc" id="L105">    Instruments instruments = new Instruments();</span>
<span class="nc" id="L106">    instruments.classLoader = cl;</span>
<span class="nc" id="L107">    return instruments.internalSizeOf(obj);</span>
  }

  /**
   * Size of.
   *
   * @param obj the obj
   * @param objects the objects
   *
   * @return the long
   */
  public static long sizeOf(Object obj, Set&lt;Object&gt; objects) {
<span class="nc" id="L119">    Instruments instruments = new Instruments();</span>
<span class="nc" id="L120">    instruments.processedObjects = objects;</span>
<span class="nc" id="L121">    return instruments.internalSizeOf(obj);</span>
  }

  /**
   * Internal size of.
   *
   * @param root the root
   *
   * @return the long
   */
  private long internalSizeOf(Object root) {
<span class="fc" id="L132">    long size = 0;</span>
<span class="fc" id="L133">    thisQueue.add(root);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">    while (!thisQueue.isEmpty()) {</span>
<span class="fc" id="L135">      Iterator&lt;Object&gt; it = thisQueue.iterator();</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">      while (it.hasNext()) {</span>
<span class="fc" id="L137">        Object obj = it.next();</span>
<span class="pc bpc" id="L138" title="3 of 6 branches missed.">        if (isInitialized() &amp;&amp; obj != null</span>
<span class="pc bpc" id="L139" title="3 of 4 branches missed.">            &amp;&amp; (classLoader == null || classLoader == obj.getClass().getClassLoader())</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">            &amp;&amp; (!IGNORE_NIO || !obj.getClass().getName().startsWith(&quot;java.nio.&quot;))) {</span>
<span class="fc" id="L141">          ObjectWrapper ow = new ObjectWrapper(obj);</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">          if (!processedObjects.contains(ow)) {</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">            if (obj.getClass().isArray()) {</span>
<span class="nc" id="L144">              size += sizeOfArray(obj);</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">            } else if (obj.getClass().isPrimitive()) {</span>
<span class="nc" id="L146">              size += sizeOfPrimitive(obj.getClass());</span>
            } else {
<span class="fc" id="L148">              processedObjects.add(ow);</span>
<span class="fc" id="L149">              size += sizeOfObject(obj);</span>
            }
          }
        }
<span class="fc" id="L153">        it.remove();</span>
<span class="fc" id="L154">      }</span>
      // avoids ConcurrentModificationException
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">      if (!nextQueue.isEmpty()) {</span>
<span class="nc" id="L157">        thisQueue.addAll(nextQueue);</span>
<span class="nc" id="L158">        nextQueue.clear();</span>
      }
<span class="fc" id="L160">    }</span>
<span class="fc" id="L161">    return size;</span>
  }

  /**
   * Size of object.
   *
   * @param obj the obj
   *
   * @return the long
   */
  private long sizeOfObject(Object obj) {
<span class="fc" id="L172">    long size = SIZE_OBJECT;</span>
<span class="fc" id="L173">    Class&lt;? extends Object&gt; clazz = obj.getClass();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">    while (clazz != null) {</span>
<span class="fc" id="L175">      Field[] fields = clazz.getDeclaredFields();</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">      for (Field field : fields) {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (!Modifier.isStatic(field.getModifiers())) {</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">          if (field.getType().isPrimitive()) {</span>
<span class="fc" id="L179">            size += sizeOfPrimitive(field.getType());</span>
          } else {
<span class="nc" id="L181">            Object val = ACCESSOR.get(obj, field);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">            if (field.getType().isArray()) {</span>
<span class="nc" id="L183">              size += sizeOfArray(val);</span>
            } else {
<span class="nc" id="L185">              size += SIZE_REFERENCE;</span>
<span class="nc" id="L186">              nextQueue.add(val);</span>
            }
          }
        }
      }
<span class="fc" id="L191">      clazz = clazz.getSuperclass();</span>
<span class="fc" id="L192">    }</span>
<span class="fc" id="L193">    return size;</span>
  }

  /**
   * Size of array.
   *
   * @param obj the obj
   *
   * @return the long
   */
  private long sizeOfArray(Object obj) {
<span class="nc bnc" id="L204" title="All 2 branches missed.">    if (obj != null) {</span>
<span class="nc" id="L205">      Class&lt;?&gt; ct = obj.getClass().getComponentType();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">      if (ct.isPrimitive()) {</span>
<span class="nc" id="L207">        return Array.getLength(obj) * sizeOfPrimitive(ct);</span>
      }
<span class="nc bnc" id="L209" title="All 2 branches missed.">      for (int i = 0; i &lt; Array.getLength(obj); i++) {</span>
<span class="nc" id="L210">        nextQueue.add(Array.get(obj, i));</span>
      }
    }
<span class="nc" id="L213">    return 0;</span>
  }

  /**
   * Size of primitive.
   *
   * @param &lt;T&gt; the generic type
   * @param type the type
   *
   * @return the long
   */
  private static &lt;T&gt; long sizeOfPrimitive(Class&lt;T&gt; type) {
<span class="fc bfc" id="L225" title="All 2 branches covered.">    if (type == Boolean.TYPE) {</span>
<span class="fc" id="L226">      return SIZE_BOOLEAN;</span>
    }
<span class="fc bfc" id="L228" title="All 2 branches covered.">    if (type == Byte.TYPE) {</span>
<span class="fc" id="L229">      return SIZE_BYTE;</span>
    }
<span class="fc bfc" id="L231" title="All 2 branches covered.">    if (type == Character.TYPE) {</span>
<span class="fc" id="L232">      return SIZE_CHAR;</span>
    }
<span class="fc bfc" id="L234" title="All 2 branches covered.">    if (type == Short.TYPE) {</span>
<span class="fc" id="L235">      return SIZE_SHORT;</span>
    }
<span class="fc bfc" id="L237" title="All 2 branches covered.">    if (type == Integer.TYPE) {</span>
<span class="fc" id="L238">      return SIZE_INT;</span>
    }
<span class="fc bfc" id="L240" title="All 2 branches covered.">    if (type == Long.TYPE) {</span>
<span class="fc" id="L241">      return SIZE_LONG;</span>
    }
<span class="fc bfc" id="L243" title="All 2 branches covered.">    if (type == Float.TYPE) {</span>
<span class="fc" id="L244">      return SIZE_FLOAT;</span>
    }
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">    if (type == Double.TYPE) {</span>
<span class="fc" id="L247">      return SIZE_DOUBLE;</span>
    }
<span class="nc bnc" id="L249" title="All 2 branches missed.">    if (type == Void.TYPE) {</span>
<span class="nc" id="L250">      return SIZE_VOID;</span>
    }
<span class="nc" id="L252">    return SIZE_REFERENCE;</span>
  }

  /**
   * Checks if is initialized.
   *
   * @return true, if is initialized
   */
  public static boolean isInitialized() {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">    return ACCESSOR != null;</span>
  }

  /**
   * Gets the field.
   *
   * @param obj the obj
   * @param name the name
   *
   * @return the field
   */
  public static Object getField(Object obj, String name) {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">    if (isInitialized()) {</span>
<span class="fc" id="L274">      Field field = findField(obj.getClass(), name);</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">      if (field != null) {</span>
<span class="fc" id="L276">        return ACCESSOR.get(obj, field);</span>
      }
    }
<span class="nc" id="L279">    return null;</span>
  }

  /**
   * Find field.
   *
   * @param &lt;T&gt; the generic type
   * @param clazz the clazz
   * @param name the name
   *
   * @return the field
   */
  public static &lt;T&gt; Field findField(Class&lt;T&gt; clazz, String name) {
<span class="fc" id="L292">    Field[] fields = clazz.getDeclaredFields();</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">    for (Field field : fields) {</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">      if (name.equals(field.getName())) {</span>
<span class="fc" id="L295">        return field;</span>
      }
    }
<span class="nc" id="L298">    Class&lt;?&gt; superClass = clazz.getSuperclass();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">    if (superClass != null) {</span>
<span class="nc" id="L300">      return findField(superClass, name);</span>
    }
<span class="nc" id="L302">    return null;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>